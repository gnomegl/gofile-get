#!/usr/bin/env bash

# @describe Download files from GoFile.io links
# @arg url! "GoFile URL (e.g., 'https://gofile.io/d/contentid') or file containing URLs"
# @option -p --password "Password for protected links" [string]
# @option -d --download-dir "Download directory (can also use GF_DOWNLOADDIR env var)" [string]
# @option -w --workers "Maximum parallel download workers" [int] @default "5"
# @option -t --token "GoFile API token (can also use GF_TOKEN env var)" [string]
# @flag -j --json "Output file information as JSON without downloading"
# @flag -l --list "List files without downloading"
# @flag -q --quiet "Suppress progress output"
# @flag -h --help "Show help information"
# @meta require-tools curl,jq

# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    _argc_require_tools "${_argc_tools[@]}"
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
Download files from GoFile.io links

USAGE: gofile-get [OPTIONS] <URL>

ARGS:
  <URL>  "GoFile URL (e.g., 'https://gofile.io/d/contentid') or file containing URLs"

OPTIONS:
  -p, --password <PASSWORD>          "Password for protected links" [string]
  -d, --download-dir <DOWNLOAD-DIR>  "Download directory (can also use GF_DOWNLOADDIR env var)" [string]
  -w, --workers <WORKERS>            "Maximum parallel download workers" [int] @default "5"
  -t, --token <TOKEN>                "GoFile API token (can also use GF_TOKEN env var)" [string]
  -j, --json                         "Output file information as JSON without downloading"
  -l, --list                         "List files without downloading"
  -q, --quiet                        "Suppress progress output"
  -h, --help                         "Show help information"
  -V, --version                      Print version
EOF
    exit
}

_argc_version() {
    echo gofile-get 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --password | -p)
            _argc_take_args "--password <PASSWORD>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_password:-}" ]]; then
                argc_password="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--password\` cannot be used multiple times"
            fi
            ;;
        --download-dir | -d)
            _argc_take_args "--download-dir <DOWNLOAD-DIR>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_download_dir:-}" ]]; then
                argc_download_dir="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--download-dir\` cannot be used multiple times"
            fi
            ;;
        --workers | -w)
            _argc_take_args "--workers <WORKERS>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_workers:-}" ]]; then
                argc_workers="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--workers\` cannot be used multiple times"
            fi
            ;;
        --token | -t)
            _argc_take_args "--token <TOKEN>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_token:-}" ]]; then
                argc_token="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--token\` cannot be used multiple times"
            fi
            ;;
        --json | -j)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--json\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_json:-}" ]]; then
                _argc_die "error: the argument \`--json\` cannot be used multiple times"
            else
                argc_json=1
            fi
            ;;
        --list | -l)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--list\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_list:-}" ]]; then
                _argc_die "error: the argument \`--list\` cannot be used multiple times"
            else
                argc_list=1
            fi
            ;;
        --quiet | -q)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--quiet\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_quiet:-}" ]]; then
                _argc_die "error: the argument \`--quiet\` cannot be used multiple times"
            else
                argc_quiet=1
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    _argc_tools=(curl jq)
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        argc__fn=main
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 0
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_url="${argc__positionals[values_index]}"
        else
            _argc_die "error: the required environments \`<URL>\` were not provided"
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_require_tools() {
    local tool missing_tools=()
    for tool in "$@"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    if [[ "${#missing_tools[@]}" -gt 0 ]]; then
        echo "error: missing tools: ${missing_tools[*]}" >&2
        exit 1
    fi
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

set -euo pipefail

if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
  NEW_LINE=$'\r\n'
else
  NEW_LINE=$'\n'
fi

LOCK_FILE="/tmp/gofile_downloader.lock"
TOKEN=""
MESSAGE=" "
CONTENT_DIR=""
ROOT_DIR=""
declare -A FILES_INFO
declare -A PATHING_COUNT
FILE_INDEX=0

setup_colors() {
  if [ "${argc_quiet:-0}" = 1 ] || [ -z "$TERM" ] || [ "$TERM" = "dumb" ]; then
    bold="" reset="" blue="" green="" yellow="" cyan="" magenta="" red=""
  else
    bold=$(tput bold) reset=$(tput sgr0) blue=$(tput setaf 4) green=$(tput setaf 2)
    yellow=$(tput setaf 3) cyan=$(tput setaf 6) magenta=$(tput setaf 5) red=$(tput setaf 1)
  fi
}
setup_colors

bold_text() {
  printf "${bold}%s${reset}" "$1"
}

red() {
  printf "${red}%s${reset}" "$1"
}

green() {
  printf "${green}%s${reset}" "$1"
}

yellow() {
  printf "${yellow}%s${reset}" "$1"
}

blue() {
  printf "${blue}%s${reset}" "$1"
}

cyan() {
  printf "${cyan}%s${reset}" "$1"
}

magenta() {
  printf "${magenta}%s${reset}" "$1"
}

_print() {
  local msg="$1"
  local error="${2:-false}"

  if [[ "${argc_quiet:-0}" = 1 ]] && [[ "$error" != "true" ]]; then
    return
  fi

  if [[ "$error" == "true" ]]; then
    echo -n "$msg" >&2
  else
    echo -n "$msg"
  fi
}

die() {
  local msg="$1"
  printf "$(red "Error"): %s${NEW_LINE}" "$msg" >&2
  exit 1
}

show_help() {
  echo "$(bold_text "GoFile Downloader")"
  echo ""
  echo "$(bold_text "Description"):"
  echo "  Download files from GoFile.io links with support for folders and password protection"
  echo ""
  echo "$(bold_text "Usage"):"
  echo "  $(green "$(basename "$0") <url>")"
  echo "  $(green "$(basename "$0") <file-with-urls>")"
  echo "  $(green "$(basename "$0") --help")"
  echo ""
  echo "$(bold_text "Examples"):"
  echo "  $(green "$(basename "$0") https://gofile.io/d/abc123")"
  echo "  $(green "$(basename "$0") https://gofile.io/d/xyz789 --password mypass")"
  echo "  $(green "$(basename "$0") urls.txt --workers 10")"
  echo ""
  echo "$(bold_text "Options"):"
  echo "  $(yellow "-p, --password")      Password for protected links"
  echo "  $(yellow "-d, --download-dir")  Download directory"
  echo "  $(yellow "-w, --workers")       Maximum parallel download workers (default: 5)"
  echo "  $(yellow "-t, --token")         GoFile API token"
  echo "  $(yellow "-j, --json")          Output file information as JSON"
  echo "  $(yellow "-l, --list")          List files without downloading"
  echo "  $(yellow "-q, --quiet")         Suppress progress output"
  echo ""
  echo "$(bold_text "Environment Variables"):"
  echo "  $(cyan "GF_TOKEN")         GoFile API token"
  echo "  $(cyan "GF_DOWNLOADDIR")   Default download directory"
  echo ""
  echo "$(bold_text "File Format"):"
  echo "  When using a file with URLs, each line should contain:"
  echo "  $(cyan "<url> [password]")"
  echo ""
  echo "  Example file content:"
  echo "  $(cyan "https://gofile.io/d/abc123")"
  echo "  $(cyan "https://gofile.io/d/xyz789 mypassword")"
}

get_token() {
  local response

  _print "$(cyan "Obtaining API token...")${NEW_LINE}"

  response=$(curl -s --compressed -X POST "https://api.gofile.io/accounts" \
    -H "User-Agent: Mozilla/5.0" \
    -H "Accept-Encoding: gzip, deflate" \
    -H "Accept: application/json" \
    -H "Connection: keep-alive" 2>&1) || {
    die "Failed to connect to GoFile API"
  }

  response=$(echo "$response" | tr -cd '[:print:][:space:]')

  if ! echo "$response" | jq . &>/dev/null; then
    _print "$(yellow "Retrying with alternative user agent...")${NEW_LINE}"

    response=$(curl -s --compressed -X POST "https://api.gofile.io/accounts" \
      -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
      -H "Accept: application/json")

    response=$(echo "$response" | tr -cd '[:print:][:space:]')

    if ! echo "$response" | jq . &>/dev/null; then
      die "Account creation failed: Invalid response from GoFile API"
    fi
  fi

  local status=$(echo "$response" | jq -r '.status // "error"')
  if [[ "$status" != "ok" ]]; then
    local error_msg=$(echo "$response" | jq -r '.message // "Unknown error"')
    die "Account creation failed: $error_msg"
  fi

  TOKEN=$(echo "$response" | jq -r '.data.token // empty')
  if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then
    die "Failed to extract token from API response"
  fi

  _print "$(green "Successfully obtained API token")${NEW_LINE}"
}

get_api_token() {
  if [ -n "${argc_token:-}" ]; then
    TOKEN="$argc_token"
  elif [ -n "${GF_TOKEN:-}" ]; then
    TOKEN="$GF_TOKEN"
  else
    get_token
  fi
}

create_dir() {
  local dirname="$1"
  mkdir -p "$dirname" 2>/dev/null || true
}

format_size() {
  local size="$1"
  local unit="B"

  if ((size >= 1024 * 1024 * 1024)); then
    size=$(echo "scale=2; $size / (1024*1024*1024)" | bc 2>/dev/null || echo "$size")
    unit="GB"
  elif ((size >= 1024 * 1024)); then
    size=$(echo "scale=2; $size / (1024*1024)" | bc 2>/dev/null || echo "$size")
    unit="MB"
  elif ((size >= 1024)); then
    size=$(echo "scale=2; $size / 1024" | bc 2>/dev/null || echo "$size")
    unit="KB"
  fi

  echo "${size}${unit}"
}

download_content() {
  local path="$1"
  local filename="$2"
  local url="$3"
  local filepath="${path}/${filename}"

  if [[ -f "$filepath" && -s "$filepath" ]]; then
    _print "$(yellow "Skipping"): ${filepath} already exists${NEW_LINE}"
    return
  fi

  local tmp_file="${filepath}.part"

  local part_size=0
  local range_header=""
  if [[ -f "$tmp_file" ]]; then
    part_size=$(stat -f%z "$tmp_file" 2>/dev/null || stat -c%s "$tmp_file" 2>/dev/null || echo 0)
    if [[ $part_size -gt 0 ]]; then
      range_header="-H \"Range: bytes=${part_size}-\""
    fi
  fi

  local curl_cmd="curl -L -s --compressed -C - -o \"$tmp_file\" \
        -H \"Cookie: accountToken=$TOKEN\" \
        -H \"Accept-Encoding: gzip, deflate\" \
        -H \"User-Agent: Mozilla/5.0\" \
        -H \"Accept: */*\" \
        -H \"Connection: keep-alive\""

  if [[ -n "$range_header" ]]; then
    curl_cmd="$curl_cmd $range_header"
  fi

  local header_cmd="${curl_cmd//-o \"$tmp_file\"/-I} \"$url\""
  local headers=$(eval $header_cmd 2>/dev/null)
  local total_size=$(echo "$headers" | grep -i "Content-Length:" | tail -1 | awk '{print $2}' | tr -d '\r')

  if [[ -z "$total_size" ]]; then
    total_size="unknown"
  fi

  curl_cmd="$curl_cmd \"$url\""

  eval $curl_cmd &
  local pid=$!
  local start_time=$(date +%s 2>/dev/null || date +%s)

  if [[ "${argc_quiet:-0}" != 1 ]]; then
    while kill -0 $pid 2>/dev/null; do
      if [[ -f "$tmp_file" ]]; then
        local current_size=$(stat -f%z "$tmp_file" 2>/dev/null || stat -c%s "$tmp_file" 2>/dev/null || echo 0)

        (
          flock -x 200
          printf "\r%-${#MESSAGE}s" " "
          if [[ "$total_size" != "unknown" ]]; then
            local progress=$(echo "scale=1; $current_size * 100 / $total_size" | bc 2>/dev/null || echo "0")
            MESSAGE="$(cyan "Downloading") ${filename}: $(format_size $current_size) of $(format_size $total_size) (${progress}%)"
          else
            MESSAGE="$(cyan "Downloading") ${filename}: $(format_size $current_size)"
          fi
          printf "\r%s" "$MESSAGE"
        ) 200>"$LOCK_FILE"
      fi
      sleep 0.5
    done
  else
    wait $pid
  fi

  local exit_code=$?

  if [[ $exit_code -eq 0 && -f "$tmp_file" ]]; then
    mv "$tmp_file" "$filepath"
    if [[ "${argc_quiet:-0}" != 1 ]]; then
      (
        flock -x 200
        printf "\r%-${#MESSAGE}s" " "
        _print "$(green "Downloaded"): ${filename}${NEW_LINE}"
      ) 200>"$LOCK_FILE"
    fi
  else
    _print "$(red "Failed"): ${filename}${NEW_LINE}"
  fi
}

parse_links_recursively() {
  local content_id="$1"
  local password="$2"
  local current_path="$3"

  local url="https://api.gofile.io/contents/${content_id}?wt=4fd6sg89d7s6&cache=true"

  if [[ -n "$password" ]]; then
    url="${url}&password=${password}"
  fi

  local response=$(curl -s --compressed "$url" \
    -H "User-Agent: Mozilla/5.0" \
    -H "Accept-Encoding: gzip, deflate" \
    -H "Accept: application/json" \
    -H "Authorization: Bearer $TOKEN" 2>&1) || {
    _print "$(red "Failed to fetch content from") ${url}${NEW_LINE}"
    return $file_index
  }

  response=$(echo "$response" | tr -cd '[:print:][:space:]')

  if ! echo "$response" | jq . &>/dev/null; then
    _print "$(red "Invalid JSON response from") ${url}${NEW_LINE}"
    return $file_index
  fi

  local status=$(echo "$response" | jq -r '.status // "error"')
  if [[ "$status" != "ok" ]]; then
    local error_msg=$(echo "$response" | jq -r '.message // "Unknown error"')
    _print "$(red "API Error"): ${error_msg}${NEW_LINE}"
    return $file_index
  fi

  local data_type=$(echo "$response" | jq -r '.data.type')
  local password_status=$(echo "$response" | jq -r '.data.passwordStatus // empty')

  if [[ -n "$password_status" && "$password_status" != "passwordOk" ]]; then
    _print "$(red "Error"): Password required or incorrect${NEW_LINE}"
    return
  fi

  if [[ "$data_type" != "folder" ]]; then
    local filename=$(echo "$response" | jq -r '.data.name')
    local link=$(echo "$response" | jq -r '.data.link')
    local size=$(echo "$response" | jq -r '.data.size // 0')
    
    FILE_INDEX=$((FILE_INDEX + 1))
    local filepath="${current_path}/${filename}"
    
    if [[ -n "${PATHING_COUNT[$filepath]:-}" ]]; then
      PATHING_COUNT[$filepath]=$((PATHING_COUNT[$filepath] + 1))
    else
      PATHING_COUNT[$filepath]=0
    fi
    
    if [[ ${PATHING_COUNT[$filepath]} -gt 0 ]]; then
      local extension="${filename##*.}"
      local basename="${filename%.*}"
      if [[ "$extension" == "$filename" ]]; then
        filename="${basename}(${PATHING_COUNT[$filepath]})"
      else
        filename="${basename}(${PATHING_COUNT[$filepath]}).${extension}"
      fi
    fi

    FILES_INFO["${FILE_INDEX}_path"]="$current_path"
    FILES_INFO["${FILE_INDEX}_filename"]="$filename"
    FILES_INFO["${FILE_INDEX}_link"]="$link"
    FILES_INFO["${FILE_INDEX}_size"]="$size"
    return
  fi

  local folder_name=$(echo "$response" | jq -r '.data.name')

  if [[ -z "$CONTENT_DIR" && "$folder_name" != "$content_id" ]]; then
    CONTENT_DIR="${ROOT_DIR}/${content_id}"
    create_dir "$CONTENT_DIR"
    cd "$CONTENT_DIR"
    current_path="$CONTENT_DIR"
  elif [[ -z "$CONTENT_DIR" && "$folder_name" == "$content_id" ]]; then
    CONTENT_DIR="${ROOT_DIR}/${content_id}"
    create_dir "$CONTENT_DIR"
    current_path="$CONTENT_DIR"
  fi
  
  if [[ -n "$CONTENT_DIR" && "$folder_name" != "$content_id" ]]; then
    local absolute_path="${current_path}/${folder_name}"
    
    if [[ -n "${PATHING_COUNT[$absolute_path]:-}" ]]; then
      PATHING_COUNT[$absolute_path]=$((PATHING_COUNT[$absolute_path] + 1))
    else
      PATHING_COUNT[$absolute_path]=0
    fi
    
    if [[ ${PATHING_COUNT[$absolute_path]} -gt 0 ]]; then
      absolute_path="${absolute_path}(${PATHING_COUNT[$absolute_path]})"
    fi
    
    create_dir "$absolute_path"
    cd "$absolute_path"
    current_path="$absolute_path"
  fi

  local children=$(echo "$response" | jq -r '.data.children | to_entries[] | @base64' 2>/dev/null)

  while IFS= read -r child_data; do
    if [[ -z "$child_data" ]]; then
      continue
    fi

    local decoded=$(echo "$child_data" | base64 -d 2>/dev/null || echo "$child_data" | base64 -D 2>/dev/null)

    local child_id=$(echo "$decoded" | jq -r '.key')
    local child_type=$(echo "$decoded" | jq -r '.value.type')

    if [[ "$child_type" == "folder" ]]; then
      local child_folder_id=$(echo "$decoded" | jq -r '.value.id')
      parse_links_recursively "$child_folder_id" "$password" "$current_path"
    else
      local child_filename=$(echo "$decoded" | jq -r '.value.name')
      local child_link=$(echo "$decoded" | jq -r '.value.link')
      local child_size=$(echo "$decoded" | jq -r '.value.size // 0')
      
      FILE_INDEX=$((FILE_INDEX + 1))
      local filepath="${current_path}/${child_filename}"
      
      if [[ -n "${PATHING_COUNT[$filepath]:-}" ]]; then
        PATHING_COUNT[$filepath]=$((PATHING_COUNT[$filepath] + 1))
      else
        PATHING_COUNT[$filepath]=0
      fi
      
      if [[ ${PATHING_COUNT[$filepath]} -gt 0 ]]; then
        local extension="${child_filename##*.}"
        local basename="${child_filename%.*}"
        if [[ "$extension" == "$child_filename" ]]; then
          child_filename="${basename}(${PATHING_COUNT[$filepath]})"
        else
          child_filename="${basename}(${PATHING_COUNT[$filepath]}).${extension}"
        fi
      fi

      FILES_INFO["${FILE_INDEX}_path"]="$current_path"
      FILES_INFO["${FILE_INDEX}_filename"]="$child_filename"
      FILES_INFO["${FILE_INDEX}_link"]="$child_link"
      FILES_INFO["${FILE_INDEX}_size"]="$child_size"
    fi
  done <<< "$children"
  
  if [[ -n "$CONTENT_DIR" ]]; then
    cd ..
  fi
}

print_list_files() {
  local index=1
  local total_size=0

  _print "$(bold_text "$(green "=== File List ===")")${NEW_LINE}"

  while [[ -n "${FILES_INFO[${index}_path]:-}" ]]; do
    local filepath="${FILES_INFO[${index}_path]}/${FILES_INFO[${index}_filename]}"
    local size="${FILES_INFO[${index}_size]:-0}"
    total_size=$((total_size + size))

    if [[ ${#filepath} -gt 100 ]]; then
      filepath="...${filepath: -97}"
    fi

    printf "$(yellow "[%d]") %s $(cyan "(%s)")${NEW_LINE}" "$index" "$filepath" "$(format_size $size)"
    index=$((index + 1))
  done

  _print "${NEW_LINE}$(bold_text "Total"): $((index - 1)) files, $(format_size $total_size)${NEW_LINE}"
}

output_json() {
  local index=1
  local json_array="["
  local first=true

  while [[ -n "${FILES_INFO[${index}_path]:-}" ]]; do
    if [[ "$first" != "true" ]]; then
      json_array+=","
    fi
    first=false

    json_array+=$(jq -n \
      --arg path "${FILES_INFO[${index}_path]}" \
      --arg filename "${FILES_INFO[${index}_filename]}" \
      --arg link "${FILES_INFO[${index}_link]}" \
      --arg size "${FILES_INFO[${index}_size]:-0}" \
      '{
                path: $path,
                filename: $filename,
                link: $link,
                size: ($size | tonumber),
                full_path: ($path + "/" + $filename)
            }')
    index=$((index + 1))
  done

  json_array+="]"
  echo "$json_array" | jq .
}

threaded_downloads() {
  if [[ -z "$CONTENT_DIR" ]]; then
    return
  fi

  cd "$CONTENT_DIR"

  local index=1
  local jobs=0
  local total_files=0
  local max_workers="${argc_workers:-5}"

  while [[ -n "${FILES_INFO[${index}_path]:-}" ]]; do
    total_files=$((total_files + 1))
    index=$((index + 1))
  done

  if [[ $total_files -eq 0 ]]; then
    _print "$(yellow "No files to download")${NEW_LINE}"
    return
  fi

  _print "$(bold_text "Starting download"): ${total_files} files with ${max_workers} workers${NEW_LINE}${NEW_LINE}"

  index=1
  local completed=0

  while [[ -n "${FILES_INFO[${index}_path]:-}" ]]; do
    if [[ $jobs -ge $max_workers ]]; then
      wait -n
      jobs=$((jobs - 1))
      completed=$((completed + 1))
    fi

    download_content "${FILES_INFO[${index}_path]}" "${FILES_INFO[${index}_filename]}" "${FILES_INFO[${index}_link]}" &
    jobs=$((jobs + 1))
    index=$((index + 1))
  done

  wait
  cd "$ROOT_DIR"

  _print "${NEW_LINE}$(green "Download complete"): ${total_files} files${NEW_LINE}"
}

reset_properties() {
  MESSAGE=" "
  CONTENT_DIR=""
  FILE_INDEX=0
  unset FILES_INFO
  unset PATHING_COUNT
  declare -gA FILES_INFO
  declare -gA PATHING_COUNT
}

download() {
  local url="$1"
  local password="$2"

  local content_id
  if [[ "$url" =~ /d/([^/]+)$ ]]; then
    content_id="${BASH_REMATCH[1]}"
  else
    _print "$(red "Invalid GoFile URL"): ${url}${NEW_LINE}"
    return
  fi

  _print "$(bold_text "Processing"): $(cyan "$url")${NEW_LINE}"
  
  if [[ -z "$TOKEN" ]]; then
    get_api_token
  fi

  local hashed_password=""
  if [[ -n "$password" ]]; then
    if command -v sha256sum &>/dev/null; then
      hashed_password=$(echo -n "$password" | sha256sum | cut -d' ' -f1)
    elif command -v openssl &>/dev/null; then
      hashed_password=$(echo -n "$password" | openssl dgst -sha256 | sed 's/^.* //')
    else
      _print "$(yellow "Warning"): Cannot hash password, using plain text${NEW_LINE}"
      hashed_password="$password"
    fi
  fi

  cd "$ROOT_DIR"
  parse_links_recursively "$content_id" "$hashed_password" "$ROOT_DIR"
  
  local file_count=0
  local index=1
  while [[ -n "${FILES_INFO[${index}_path]:-}" ]]; do
    file_count=$((file_count + 1))
    index=$((index + 1))
  done

  if [[ $file_count -eq 0 ]]; then
    _print "$(yellow "No content found for"): ${url}${NEW_LINE}"
    reset_properties
    return
  fi

  if [[ "${argc_json:-0}" = 1 ]]; then
    output_json
    reset_properties
    return
  fi

  if [[ "${argc_list:-0}" = 1 ]]; then
    print_list_files
    reset_properties
    return
  fi

  threaded_downloads
  reset_properties
}

parse_url_or_file() {
  local url_or_file="$1"
  local password="${argc_password:-}"

  if [[ ! -f "$url_or_file" ]]; then
    download "$url_or_file" "$password"
    return
  fi

  _print "$(bold_text "Processing URL file"): $(cyan "$url_or_file")${NEW_LINE}"
  local line_num=0

  while IFS=' ' read -r url pass || [[ -n "$url" ]]; do
    line_num=$((line_num + 1))
    url=$(echo "$url" | tr -d '[:space:]')

    if [[ -z "$url" ]] || [[ "$url" =~ ^# ]]; then
      continue
    fi

    if [[ -n "$password" ]]; then
      pass="$password"
    else
      pass=$(echo "$pass" | tr -d '[:space:]')
    fi

    _print "${NEW_LINE}$(bold_text "[Line $line_num]")${NEW_LINE}"
    download "$url" "$pass"
  done <"$url_or_file"
}

check_dependencies() {
  local missing=()

  if ! command -v curl &>/dev/null; then
    missing+=("curl")
  fi

  if ! command -v jq &>/dev/null; then
    missing+=("jq")
  fi

  if [[ ${#missing[@]} -gt 0 ]]; then
    die "Missing required tools: ${missing[*]}"
  fi

  if ! command -v bc &>/dev/null; then
    _print "$(yellow "Warning"): bc not found, some features limited${NEW_LINE}"
  fi

  if ! command -v sha256sum &>/dev/null && ! command -v openssl &>/dev/null; then
    _print "$(yellow "Warning"): No SHA256 tool found, password hashing disabled${NEW_LINE}"
  fi
}

main() {
  check_dependencies

  if [[ -n "${argc_download_dir:-}" ]]; then
    ROOT_DIR="${argc_download_dir}"
  elif [[ -n "${GF_DOWNLOADDIR:-}" ]]; then
    ROOT_DIR="${GF_DOWNLOADDIR}"
  else
    ROOT_DIR=$(pwd)
  fi

  if [[ ! -d "$ROOT_DIR" ]]; then
    die "Download directory does not exist: $ROOT_DIR"
  fi

  cd "$ROOT_DIR" || die "Cannot change to download directory: $ROOT_DIR"

  local url="${argc_url}"

  if [[ ! -f "$url" ]] && [[ ! "$url" =~ ^https?://gofile\.io/d/ ]]; then
    die "Invalid GoFile URL. Expected format: https://gofile.io/d/contentid"
  fi

  touch "$LOCK_FILE"
  parse_url_or_file "$url" "${argc_password:-}"
  rm -f "$LOCK_FILE"
}

if [[ "${argc_help:-0}" = 1 ]]; then
  show_help
  exit 0
fi

main
